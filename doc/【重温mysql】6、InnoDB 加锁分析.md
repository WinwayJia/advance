# 【重温mysql】6、InnoDB 加锁分析

InnoDB 为了保证并发能力，采取行级加锁策略。为了实现事务的隔离级别，InnoDB 中又引入了各种不同的行级锁机制。不同的加锁顺序、加锁类型、锁的多少以及影响范围将直接影响到整个事务执行效率与执行时间直接影响 MySQL 的吞吐能力，不恰当的加锁策略甚至有可能产生死锁，因此我们又必要对整个过程有所了解。

# 加锁策略与影响因素

InnoDB 采用了 B+ Tree 的数据结构与聚集索引的数据组织形式，**索引在 InnoDB 引擎中占据了非常重要的位置，InnoDB 加锁过程就是对索引进行加锁的一个过程**。在分析 InnoDB 加锁之前，我们需要知道 InnoDB 加锁是和什么有关，这一点非常重要。对于不同的事务隔离离别、不同的列 InnoDB 采取的策略与使用的锁的类型都不一样，影响加锁的因素有如下两种：

- **事务隔离级别**，对于不同的事务隔离级别，InnoDB 采取的策略不一样。比如对于 `select ... from` 这类语句而言，由于 InnoDB 采取了一致性读策略，一般是不会加锁的，但是在`Serialzable` 级别，InnoDB 会对搜索过程中遇到的二级索引加`共享临键锁`。对于`Read Committed`级别不会采取`间隙锁`的加锁策略。
- **索引**，由于InnoDB 采取了聚集索引的数据组织策略，因此对于主键和二级索引，它们的加锁过程是不同的。对于主键索引只需对主键上进行加锁即可，而对于二级索引加锁后还需对其指向数据的主键进行加锁。
- **加锁语句**，InnoDB在不同事务隔离级别下，对于不同的加锁语句，采取的策略不同。如对于`update ... from ...` 语句在`Read Repeatable`级别下使用了`排他临键锁`，而在`Read Committed`级别下使用的是`排他行锁`。

# 基本加锁原则

对于 InnoDB 而言，虽然加锁的类别繁多，加锁形式也灵活多样，但也遵循了一些原则：

- **对于select ... from ... 语句，使用快照读，一般情况下不加锁，仅在Serializable级别会加共享读锁**
- **对于select ... from ... lock in share mode语句使用当前读，加共享读锁(S锁)**
- **对于 select ... from ... for update语句，为当前读，加排他写锁(X锁)**
- **常见 DML语句（insert、delete、update），使用当前读，加排他写锁(X锁)**
- **常见 DDL语句(alter table,create table ...)等，加的是表级锁**


作者：tiger链接：https://juejin.im/post/5dc6c5325188250b92054dd8来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。